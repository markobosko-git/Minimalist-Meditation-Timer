<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zen Timer</title>
    <style>
        :root {
            --text-color: #B3B3B3;
            --accent-color: #886600;
            --bg-color: #000;
            --fade-out: 5s;
            --fade-in: 1s;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        body.full-screen {
            padding: 0;
        }
        
        #clock {
            position: absolute;
            top: 10px;
            font-size: 14px;
            text-align: center;
            width: 100%;
            padding: 5px;
            transition: opacity var(--fade-out) ease;
        }
        
        #timer-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }
        
        #timer-display {
            text-align: center;
            font-size: 24vw; /* 20% larger than original 20vw */
            line-height: 1;
            width: 100%;
            cursor: pointer;
            user-select: none;
        }
        
        @media (orientation: landscape) {
            #timer-display { font-size: 30vh; } /* 20% larger than original 25vh */
        }
        
        @media (orientation: portrait) {
            #timer-display { font-size: 39.6vw; } /* 20% larger than original 33vw */
        }
        
        #slider-container {
            position: relative;
            width: 90%;
            margin: 15px auto;
            transition: opacity var(--fade-out) ease;
        }
        
        #minutes-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 2px;
            background: #555;
            outline: none;
            cursor: pointer;
        }
        
        #minutes-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--text-color);
            cursor: pointer;
            transition: background 0.3s;
        }
        
        #minutes-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--text-color);
            cursor: pointer;
            transition: background 0.3s;
            border: none;
        }
        
        .yellow-thumb #minutes-slider::-webkit-slider-thumb {
            background: var(--accent-color);
        }
        
        .yellow-thumb #minutes-slider::-moz-range-thumb {
            background: var(--accent-color);
        }
        
        #minutes-value {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 12px;
            color: var(--text-color);
            transition: color 0.3s, left 0.3s;
        }
        
        #input-container {
            position: relative;
            margin-top: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity var(--fade-out) ease;
        }
        
        #timer-input {
            background-color: transparent;
            border: 2px solid var(--text-color);
            border-radius: 50%;
            color: var(--text-color);
            width: 70px;
            height: 70px;
            text-align: center;
            font-size: 18px;
            cursor: pointer;
            transition: border-color 0.3s, color 0.3s;
        }
        
        .timer-running #clock,
        .timer-running #slider-container,
        .timer-running #input-container,
        .timer-running #settings-button {
            opacity: 0 !important;
            pointer-events: none !important;
            visibility: hidden !important;
            display: none !important;
        }
        
        .timer-running #timer-container {
            justify-content: center;
        }
        
        .yellow-text {
            color: var(--accent-color) !important;
        }
        
        .yellow-border {
            border-color: var(--accent-color) !important;
        }
        
        #settings-button {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: transparent;
            border: 2px solid var(--accent-color); /* Changed to accent color */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity var(--fade-out) ease;
        }
        
        #settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            z-index: 1000;
            display: none;
            overflow: auto;
            padding-bottom: 80px;
        }
        
        #settings-content {
            position: relative;
            padding: 5px 20px;
            transform-origin: top center;
        }
        
        #settings-close-button {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: transparent;
            border: 2px solid var(--accent-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        
        #presets-container {
            padding-top: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 0 auto;
            width: 100%;
            max-width: 300px;
        }
        
        .preset-row {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .preset-radio {
            position: relative;
            width: 28px;
            height: 28px;
            margin-right: 20px;
        }
        
        .preset-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            cursor: pointer;
        }
        
        .preset-radio input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .radio-custom {
            position: absolute;
            top: 0;
            left: 0;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            border: 2px solid var(--text-color);
            background-color: transparent;
        }
        
        .preset-radio input:checked ~ .radio-custom::after {
            content: '';
            position: absolute;
            display: block;
            top: 6px;
            left: 6px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-color);
        }
        
        .preset-time-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 16px;
            text-align: center;
            width: 100%;
            outline: none;
        }
    </style>
</head>
<body>
    <div id="clock">00:00:00</div>
    
    <div id="timer-container">
        <div id="timer-display">0</div>
        <div id="slider-container">
            <span id="minutes-value">0 min</span>
            <input type="range" min="0" max="60" value="0" class="slider" id="minutes-slider">
        </div>
        <div id="input-container">
            <input type="text" id="timer-input" readonly>
        </div>
    </div>
    
    <button id="settings-button"></button>
    
    <div id="settings-panel">
        <div id="settings-content">
            <div id="presets-container">
                <!-- Preset rows will be generated here -->
            </div>
        </div>
        <!-- Yellow circle button at the bottom for closing settings -->
        <button id="settings-close-button"></button>
    </div>

    <script>
        // DOM Elements
        const els = {
            clock: document.getElementById('clock'),
            timerDisplay: document.getElementById('timer-display'),
            timerInput: document.getElementById('timer-input'),
            timerContainer: document.getElementById('timer-container'),
            minutesSlider: document.getElementById('minutes-slider'),
            minutesValue: document.getElementById('minutes-value'),
            sliderContainer: document.getElementById('slider-container'),
            settingsButton: document.getElementById('settings-button'),
            settingsPanel: document.getElementById('settings-panel'),
            settingsContent: document.getElementById('settings-content'),
            settingsCloseButton: document.getElementById('settings-close-button'),
            presetsContainer: document.getElementById('presets-container'),
            inputContainer: document.getElementById('input-container'),
            body: document.body
        };
        
        // UI elements that need fade transitions
        const fadeElements = [els.clock, els.sliderContainer, els.inputContainer, els.settingsButton];
        
        // App state
        const state = {
            timerInterval: null,
            timerValue: 0,      // Current countdown value (changes during countdown)
            masterValue: 0,     // Master value (set by user, preserved between sessions)
            timerRunning: false,
            timerTapCount: 0,   // Track taps on timer specifically
            isNegative: false,
            currentOrientation: window.innerHeight > window.innerWidth ? 'portrait' : 'landscape',
            audioContext: null,
            currentScale: loadStoredScale(), // Load from localStorage
            startDistance: 0,
            inputMode: "view", // "view", "edit"
            wakeLock: null,
            wakeLockSupported: 'wakeLock' in navigator,
            settingsScale: 1.0,
            settingsStartDistance: 0,
            isSettingsPinching: false,
            isFullScreen: false,
        };
        
        // Default presets
        const DEFAULT_PRESETS = Array(7).fill().map(() => ({ time: 0, selected: false, displayText: "0" }));

        // Min and max zoom limits - now expanded by 109%
        const ZOOM_LIMITS = {
            min: 0.5 * (1 - 0.5 * 1.09),  // Originally 0.5, now lower
            max: 1.5 * (1 + 0.5 * 1.09)   // Originally 1.5, now higher
        };
        
        // Load saved scale from local storage
        function loadStoredScale() {
            try {
                const savedScale = localStorage.getItem('timerFontScale');
                if (savedScale !== null) {
                    return parseFloat(savedScale);
                }
            } catch(e) {
                console.error('Failed to load stored scale:', e);
            }
            return 1.0; // Default if not found
        }
        
        // Save current scale to local storage
        function saveCurrentScale() {
            try {
                localStorage.setItem('timerFontScale', state.currentScale.toString());
            } catch(e) {
                console.error('Failed to save scale:', e);
            }
        }

        // Try to initialize audio context
        try {
            state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.error("Web Audio API not supported:", e);
        }

        // Initialize CSS variables
        document.documentElement.style.setProperty('--fade-out', '5s');
        document.documentElement.style.setProperty('--fade-in', '1s');
        
        // Check if fullscreen is supported
        function isFullscreenSupported() {
            return document.documentElement.requestFullscreen || 
                   document.documentElement.mozRequestFullScreen || 
                   document.documentElement.webkitRequestFullscreen || 
                   document.documentElement.msRequestFullscreen;
        }
        
        // Enter fullscreen mode
        function enterFullscreen() {
            if (!state.isFullScreen) {
                if (isFullscreenSupported()) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
                        document.documentElement.mozRequestFullScreen();
                    } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
                        document.documentElement.msRequestFullscreen();
                    }
                    
                    state.isFullScreen = true;
                    els.body.classList.add('full-screen');
                }
            }
        }
        
        // Exit fullscreen mode
        function exitFullscreen() {
            if (state.isFullScreen) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                
                state.isFullScreen = false;
                els.body.classList.remove('full-screen');
            }
        }
        
        // Track fullscreen changes
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function handleFullscreenChange() {
            // Update state to match actual fullscreen status
            const isFullscreenNow = document.fullscreenElement || 
                                  document.webkitFullscreenElement || 
                                  document.mozFullScreenElement || 
                                  document.msFullscreenElement;
            
            state.isFullScreen = !!isFullscreenNow;
            
            if (state.isFullScreen) {
                els.body.classList.add('full-screen');
            } else {
                els.body.classList.remove('full-screen');
            }
        }

        // Function to ensure UI elements are hidden when timer is running
        function hideUIElements() {
            fadeElements.forEach(element => {
                element.style.opacity = '0';
                element.style.visibility = 'hidden';
                element.style.pointerEvents = 'none';
                element.style.display = 'none';
            });
        }

        // Function to ensure UI elements are visible when timer is not running
        function showUIElements() {
            fadeElements.forEach(element => {
                element.style.opacity = '1';
                element.style.visibility = 'visible';
                element.style.pointerEvents = 'auto';
                element.style.display = '';
            });
        }

        // Function to apply fade-out transitions to UI elements
        function applyFadeOutTransition() {
            fadeElements.forEach(element => {
                element.style.transition = '';
                void element.offsetWidth; // Force reflow
                element.style.transition = 'opacity var(--fade-out) ease';
                element.style.opacity = '1'; // Reset opacity before transition
            });
        }

        // Function to apply fade-in transitions to UI elements
        function applyFadeInTransition() {
            fadeElements.forEach(element => {
                element.style.transition = '';
                void element.offsetWidth; // Force reflow
                element.style.transition = 'opacity var(--fade-in) ease';
                element.style.opacity = '1'; // Ensure opacity is set to 1
                element.style.visibility = 'visible'; // Make sure it's visible
                element.style.display = ''; // Make sure it's displayed
            });
        }

        // Update the clock
        function updateClock() {
            const now = new Date();
            els.clock.textContent = [
                String(now.getHours()).padStart(2, '0'),
                String(now.getMinutes()).padStart(2, '0'),
                String(now.getSeconds()).padStart(2, '0')
            ].join(':');
        }
        
        // Set up clock update interval
        setInterval(updateClock, 1000);
        updateClock(); // Initial update
        
        // Format time for simplified display
        function formatTime(timeInSeconds) {
            if (timeInSeconds === 0) return "0";
            
            const absValue = Math.abs(timeInSeconds);
            const hours = Math.floor(absValue / 3600);
            const minutes = Math.floor((absValue % 3600) / 60);
            const seconds = absValue % 60;
            
            let timeStr = "";
            
            if (hours > 0) {
                timeStr += hours;
                if (minutes > 0 || seconds > 0) {
                    timeStr += ":" + String(minutes).padStart(2, '0');
                    if (seconds > 0) {
                        timeStr += ":" + String(seconds).padStart(2, '0');
                    }
                }
            } else if (minutes > 0) {
                timeStr += minutes;
                if (seconds > 0) {
                    timeStr += ":" + String(seconds).padStart(2, '0');
                }
            } else {
                timeStr += seconds;
            }
            
            return timeStr;
        }
        
        // Update slider minutes label position
        function updateSliderPosition() {
            const sliderWidth = els.minutesSlider.clientWidth;
            const percentage = els.minutesSlider.value / els.minutesSlider.max;
            els.minutesValue.style.left = `${percentage * sliderWidth}px`;
        }
        
        // Update timer display and synchronize colors
        function updateTimerDisplay() {
            // Update display text with current countdown value
            els.timerDisplay.textContent = formatTime(state.timerValue);
            
            // Update colors based on value
            const isNegative = state.timerValue < 0 || state.isNegative;
            els.timerDisplay.classList.toggle('yellow-text', isNegative);
            els.timerInput.classList.toggle('yellow-border', isNegative);
            els.timerInput.style.color = isNegative ? 'var(--accent-color)' : 'var(--text-color)';
            els.sliderContainer.classList.toggle('yellow-thumb', isNegative);
            els.minutesValue.style.color = isNegative ? 'var(--accent-color)' : 'var(--text-color)';
            state.isNegative = isNegative;
            
            // Adjust font size
            adjustFontSize();
        }
        
        // Check and update orientation
        function checkOrientation() {
            const newOrientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
            if (state.currentOrientation !== newOrientation) {
                state.currentOrientation = newOrientation;
                // Do not reset scale here anymore - keep the user's preference
                adjustFontSize();
            }
        }
        
        // Adjust font size to make timer fill available width
        function adjustFontSize() {
            const containerWidth = window.innerWidth - 40;
            const containerHeight = state.timerRunning ? window.innerHeight : window.innerHeight * 0.6;
            
            // Calculate base font size with the 20% increase already applied in CSS
            let baseSize;
            if (state.currentOrientation === 'landscape') {
                baseSize = Math.min(containerWidth / 8, containerHeight / 2) * 1.2;
            } else {
                baseSize = Math.min(containerWidth / 3.3, containerHeight / 3) * 1.8; // 1.5 * 1.2 = 1.8
            }
            
            // Reset font size for measurement
            els.timerDisplay.style.fontSize = `${baseSize}px`;
            
            // Calculate scaling factors
            const textWidth = els.timerDisplay.scrollWidth;
            const textHeight = els.timerDisplay.scrollHeight;
            const widthRatio = containerWidth / textWidth;
            const heightRatio = containerHeight / textHeight;
            
            // Apply calculated font size with scaling
            const scaleFactor = Math.min(widthRatio, heightRatio) * 0.95;
            const newFontSize = baseSize * scaleFactor * state.currentScale;
            els.timerDisplay.style.fontSize = `${newFontSize}px`;
            
            // Update slider label position
            updateSliderPosition();
        }
        
        // Generate beep sound using sine wave
        function beep(frequency = 512, duration = 200, count = 1) {
            if (!state.audioContext) {
                try {
                    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Can't create audio context:", e);
                    return;
                }
            }
            
            try {
                function playBeep(index) {
                    if (index >= count) return;
                    
                    const oscillator = state.audioContext.createOscillator();
                    const gainNode = state.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = frequency;
                    oscillator.connect(gainNode);
                    gainNode.connect(state.audioContext.destination);
                    
                    const now = state.audioContext.currentTime;
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.7, now + 0.01);
                    gainNode.gain.setValueAtTime(0.7, now + duration / 1000 - 0.01);
                    gainNode.gain.linearRampToValueAtTime(0, now + duration / 1000);
                    
                    oscillator.start(now);
                    oscillator.stop(now + duration / 1000);
                    
                    setTimeout(() => playBeep(index + 1), duration + 100);
                }
                
                playBeep(0);
            } catch (e) {
                console.error("Audio playback error:", e);
            }
        }
        
        // Request wake lock to keep screen on
        async function requestWakeLock() {
            if (!state.wakeLockSupported) return;
            
            try {
                state.wakeLock = await navigator.wakeLock.request('screen');
                
                // Reacquire wake lock if released
                state.wakeLock.addEventListener('release', () => {
                    if (state.timerRunning) {
                        requestWakeLock();
                    }
                });
            } catch (err) {
                console.error(`Failed to get wake lock: ${err.name}, ${err.message}`);
            }
        }
        
        // Release wake lock
        function releaseWakeLock() {
            if (state.wakeLock) {
                state.wakeLock.release()
                    .then(() => {
                        state.wakeLock = null;
                    })
                    .catch(err => {
                        console.error(`Failed to release wake lock: ${err.name}, ${err.message}`);
                    });
            }
        }
        
        // Start the timer
        function startTimer() {
            if (!state.timerRunning) {
                // Enter fullscreen mode
                enterFullscreen();
                
                // Apply fade-out transition before adding timer-running class
                applyFadeOutTransition();
                
                // Always start from the master value
                state.timerValue = state.masterValue;
                updateTimerDisplay();
                
                state.timerRunning = true;
                els.body.classList.add('timer-running');
                
                // Force hide UI elements to guarantee they're invisible
                hideUIElements();
                
                beep(512, 200, 2); // Two beeps when timer starts
                
                // Request wake lock
                requestWakeLock();
                
                // Start countdown interval
                state.timerInterval = setInterval(() => {
                    state.timerValue--;
                    updateTimerDisplay();
                    
                    if (state.timerValue === 0) {
                        beep(512, 200, 3); // Three beeps when timer reaches zero
                    }
                }, 1000);
                
                // Reset tap count for next sequence
                state.timerTapCount = 0;
                
                // Adjust font size
                setTimeout(adjustFontSize, 50);
                
                // Double-check UI elements are hidden after a short delay
                setTimeout(hideUIElements, 100);
            }
        }
        
        // Stop the timer
        function stopTimer() {
            if (state.timerRunning) {
                // Exit fullscreen mode
                exitFullscreen();
                
                // Apply fade-in transition
                applyFadeInTransition();
                
                // Update UI state
                state.timerRunning = false;
                els.body.classList.remove('timer-running');
                clearInterval(state.timerInterval);
                
                // Force show UI elements
                showUIElements();
                
                // Release wake lock
                releaseWakeLock();
                
                // Keep displaying current countdown value (not resetting to master yet)
                updateTimerDisplay();
                
                // Adjust font size
                setTimeout(adjustFontSize, 50);
                
                // Double-check UI elements are visible after a short delay
                setTimeout(showUIElements, 100);
            }
        }
        
        // Reset the timer (resets display to master value)
        function resetTimer() {
            clearInterval(state.timerInterval);
            state.timerRunning = false;
            els.body.classList.remove('timer-running');
            
            // Exit fullscreen if we're in it
            exitFullscreen();
            
            // Ensure all UI elements are visible with fade-in
            applyFadeInTransition();
            showUIElements();
            
            // Release wake lock
            releaseWakeLock();
            
            state.isNegative = false;
            
            // Reset display to master value
            state.timerValue = state.masterValue;
            updateTimerDisplay();
            
            beep(512, 200, 1); // One beep for reset
            
            // Reset tap count
            state.timerTapCount = 0;
            
            // Adjust font size
            setTimeout(adjustFontSize, 50);
            
            // Double-check UI elements are visible after a short delay
            setTimeout(showUIElements, 100);
        }
        
        // Update the slider to match the master value
        function updateSliderToMatchMasterValue() {
            const minutes = Math.floor(Math.abs(state.masterValue) / 60);
            els.minutesSlider.value = Math.min(60, Math.max(0, minutes));
            els.minutesValue.textContent = `${els.minutesSlider.value} min`;
            updateSliderPosition();
        }
        
        // Update master value and all UI elements
        function updateMasterValue(seconds) {
            // Set the master value
            state.masterValue = seconds;
            
            // Update input field with formatted time
            els.timerInput.value = formatTime(state.masterValue);
            
            // Update slider
            updateSliderToMatchMasterValue();
            
            // When not running, also update the display value
            if (!state.timerRunning) {
                state.timerValue = state.masterValue;
                updateTimerDisplay();
            }
        }
        
        // Parse time input and convert to seconds
        function parseTimeInput(input) {
            const digits = input.replace(/\D/g, '');
            let hours = 0, minutes = 0, seconds = 0;
            
            switch (digits.length) {
                case 1:
                case 2:
                    seconds = parseInt(digits);
                    break;
                case 3:
                    minutes = parseInt(digits[0]);
                    seconds = parseInt(digits.substring(1));
                    break;
                case 4:
                    minutes = parseInt(digits.substring(0, 2));
                    seconds = parseInt(digits.substring(2));
                    break;
                default:
                    if (digits.length >= 5) {
                        hours = parseInt(digits.substring(0, digits.length - 4));
                        minutes = parseInt(digits.substring(digits.length - 4, digits.length - 2));
                        seconds = parseInt(digits.substring(digits.length - 2));
                    }
                    break;
            }
            
            return hours * 3600 + minutes * 60 + seconds;
        }
        
        // Apply timer input and hide keyboard
        function applyTimerInput() {
            els.timerInput.readOnly = true;
            els.timerInput.blur();
            
            if (els.timerInput.value.trim() !== '') {
                const seconds = parseTimeInput(els.timerInput.value);
                updateMasterValue(seconds);
                state.inputMode = "view";
            }
        }
        
        // Handle input field click based on current mode
        function handleInputClick() {
            if (state.inputMode === "view") {
                // Enter edit mode
                els.timerInput.readOnly = false;
                els.timerInput.value = '';
                els.timerInput.focus();
                
                // Show virtual keyboard on mobile
                if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                    els.timerInput.type = 'number';
                    els.timerInput.inputMode = 'numeric';
                    els.timerInput.pattern = '[0-9]*';
                }
                state.inputMode = "edit";
            } else if (state.inputMode === "edit") {
                // Apply entered value
                applyTimerInput();
                
                // If time is set, allow immediate timer start
                if (state.masterValue > 0) {
                    startTimer();
                }
            }
        }
        
        // Update master value from slider
        function updateFromSlider() {
            const minutes = parseInt(els.minutesSlider.value);
            els.minutesValue.textContent = `${minutes} min`;
            updateSliderPosition();
            
            // Get seconds from current master value
            const currentSeconds = state.masterValue % 60;
            
            // Update master value preserving seconds
            updateMasterValue(minutes * 60 + currentSeconds);
        }
        
        // Handle taps on timer display with revised logic
        function handleTimerTap() {
            // If timer is running, first tap stops it
            if (state.timerRunning) {
                stopTimer();
                return;
            }
            
            // When timer is stopped, count taps and perform actions
            state.timerTapCount = (state.timerTapCount + 1) % 3;
            
            switch (state.timerTapCount) {
                case 1: // First tap when not running: start timer
                    startTimer();
                    break;
                case 2: // Second tap: stop timer (timer is already stopped here)
                    // No action needed, timer was already stopped by first tap
                    break;
                case 0: // Third tap (resets to 0): reset timer to initial value
                    resetTimer();
                    break;
            }
        }
        
        // Pinch gesture handlers for main timer
        function handlePinchStart(e) {
            if (e.touches.length !== 2) return;
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            state.startDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
        }
        
        function handlePinchMove(e) {
            if (e.touches.length !== 2) return;
            e.preventDefault();
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            if (state.startDistance > 0) {
                const newScale = state.currentScale * (currentDistance / state.startDistance);
                // Use expanded min and max limits (109% more than before)
                state.currentScale = Math.min(Math.max(newScale, ZOOM_LIMITS.min), ZOOM_LIMITS.max);
                state.startDistance = currentDistance;
                adjustFontSize();
                // Save the scale to localStorage when changed
                saveCurrentScale();
            }
        }
        
        // Settings panel touch handlers
        function handleSettingsPanelTouch(e) {
            if (e.type === 'touchstart' && e.touches.length === 2) {
                // Pinch gesture start
                state.isSettingsPinching = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                state.settingsStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            } else if (e.type === 'touchmove' && state.isSettingsPinching && e.touches.length === 2) {
                // Handle pinch zoom
                e.preventDefault();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (state.settingsStartDistance > 0) {
                    const newScale = state.settingsScale * (currentDistance / state.settingsStartDistance);
                    state.settingsScale = Math.min(Math.max(newScale, 0.5), 3.0);
                    state.settingsStartDistance = currentDistance;
                    
                    els.settingsContent.style.transform = `scale(${state.settingsScale})`;
                    els.settingsContent.style.transformOrigin = 'center top';
                }
            } else if (e.type === 'touchend' || e.type === 'touchcancel') {
                state.isSettingsPinching = false;
                state.settingsStartDistance = 0;
            }
        }
        
        // Function to check if an element is a UI element in settings
        function isUIElementInSettings(element) {
            // Check if the element or any of its parents is a UI element
            let current = element;
            while (current !== null && current !== els.settingsPanel) {
                // If we find the settings content, it's a UI element
                if (current === els.settingsContent || 
                    current === els.settingsCloseButton) {
                    return true;
                }
                current = current.parentElement;
            }
            return false;
        }
        
        // Handle click on settings panel background
        function handleSettingsPanelClick(e) {
            // If the click is directly on the settings panel (black background)
            // and not on any of its UI elements
            if (e.target === els.settingsPanel && !isUIElementInSettings(e.target)) {
                closeSettingsPanel();
            }
        }
        
        // Close settings panel
        function closeSettingsPanel() {
            els.settingsPanel.style.display = 'none';
        }
        
        // Presets management
        function loadPresets() {
            try {
                const stored = localStorage.getItem('timerPresets');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch(e) {
                console.error('Failed to load presets:', e);
            }
            return [...DEFAULT_PRESETS];
        }
        
        function savePresets(presets) {
            try {
                localStorage.setItem('timerPresets', JSON.stringify(presets));
            } catch(e) {
                console.error('Failed to save presets:', e);
            }
        }
        
        function createPresetsUI() {
            els.presetsContainer.innerHTML = '';
            const presets = loadPresets();
            
            presets.forEach((preset, index) => {
                const row = document.createElement('div');
                row.className = 'preset-row';
                
                // Radio button
                const radioLabel = document.createElement('label');
                radioLabel.className = 'preset-radio';
                
                const radioInput = document.createElement('input');
                radioInput.type = 'radio';
                radioInput.name = 'preset';
                radioInput.value = index;
                radioInput.checked = preset.selected;
                radioInput.addEventListener('change', () => selectPreset(index));
                
                const customRadio = document.createElement('span');
                customRadio.className = 'radio-custom';
                
                radioLabel.appendChild(radioInput);
                radioLabel.appendChild(customRadio);
                
                // Preset circle with time input
                const circle = document.createElement('div');
                circle.className = 'preset-circle';
                
                const timeInput = document.createElement('input');
                timeInput.type = 'text';
                timeInput.className = 'preset-time-input';
                timeInput.value = preset.displayText || "0";
                timeInput.dataset.index = index;
                
                timeInput.addEventListener('focus', function() {
                    this.select();
                });
                
                timeInput.addEventListener('blur', function() {
                    updatePreset(index, this.value);
                });
                
                timeInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                });
                
                circle.appendChild(timeInput);
                
                // Add to row
                row.appendChild(radioLabel);
                row.appendChild(circle);
                
                // Add to container
                els.presetsContainer.appendChild(row);
            });
        }
        
        function updatePreset(index, timeValue) {
            const presets = loadPresets();
            const seconds = parseTimeInput(timeValue);
            presets[index].time = seconds;
            presets[index].displayText = timeValue.trim() || formatTime(seconds);
            
            savePresets(presets);
            
            // Update display
            const inputs = document.querySelectorAll('.preset-time-input');
            if (inputs[index]) {
                inputs[index].value = presets[index].displayText;
            }
        }
        
        function selectPreset(index) {
            const presets = loadPresets();
            
            // Unselect all presets
            presets.forEach(preset => preset.selected = false);
            
            // Select the chosen preset
            presets[index].selected = true;
            savePresets(presets);
            
            // Update the master value from preset
            updateMasterValue(presets[index].time);
        }
        
        function applySelectedPresetOnLoad() {
            const presets = loadPresets();
            const selectedPreset = presets.find(preset => preset.selected);
            if (selectedPreset) {
                // Set the master value from the selected preset
                updateMasterValue(selectedPreset.time);
            }
        }
        
        // Event listeners
        
        // Settings panel
        els.settingsButton.addEventListener('click', function() {
            els.settingsPanel.style.display = 'block';
            state.settingsScale = 1.0;
            els.settingsContent.style.transform = 'scale(1.0)';
        });
        
        // Settings close button (the yellow circle)
        els.settingsCloseButton.addEventListener('click', closeSettingsPanel);
        
        // Add event listener to close settings when clicking on the background
        els.settingsPanel.addEventListener('click', handleSettingsPanelClick);
        
        // Timer display tap
        els.timerDisplay.addEventListener('click', handleTimerTap);
        
        // Input field
        els.timerInput.addEventListener('click', handleInputClick);
        
        // Input container
        els.inputContainer.addEventListener('click', (e) => {
            if (e.target === els.timerInput && els.timerInput.readOnly && state.masterValue > 0 && !state.timerRunning) {
                startTimer();
            }
        });
        
        // Slider
        els.minutesSlider.addEventListener('input', updateFromSlider);
        els.minutesSlider.addEventListener('change', updateFromSlider);
        
        // Keyboard input
        els.timerInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                applyTimerInput();
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                setTimeout(() => {
                    if (els.timerInput.value === '') {
                        state.inputMode = "edit";
                    }
                }, 10);
            }
        });
        
        els.timerInput.addEventListener('blur', () => {
            if (!els.timerInput.readOnly) {
                applyTimerInput();
            }
        });
        
        // Touch events for pinch zooming
        els.timerDisplay.addEventListener('touchstart', handlePinchStart, false);
        els.timerDisplay.addEventListener('touchmove', handlePinchMove, { passive: false });
        els.timerDisplay.addEventListener('touchend', () => { state.startDistance = 0; });
        
        // Touch events for settings panel
        els.settingsPanel.addEventListener('touchstart', handleSettingsPanelTouch, false);
        els.settingsPanel.addEventListener('touchmove', handleSettingsPanelTouch, { passive: false });
        els.settingsPanel.addEventListener('touchend', handleSettingsPanelTouch, false);
        els.settingsPanel.addEventListener('touchcancel', handleSettingsPanelTouch, false);
        
        // Window events
        window.addEventListener('resize', () => {
            checkOrientation();
            adjustFontSize();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                checkOrientation();
                adjustFontSize();
            }, 200);
        });
        
        // Document visibility
        document.addEventListener('visibilitychange', () => {
            if (state.wakeLockSupported && document.visibilityState === 'visible' && state.timerRunning) {
                requestWakeLock();
                
                // Re-check UI elements visibility when returning to page
                if (state.timerRunning) {
                    setTimeout(hideUIElements, 100);
                }
            }
        });
        
        // Handle escape key in fullscreen mode
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && state.isFullScreen && state.timerRunning) {
                stopTimer();
            }
        });
        
        // Initialize audio context
        window.addEventListener('click', function initAudio() {
            if (state.audioContext) {
                const buffer = state.audioContext.createBuffer(1, 1, 22050);
                const source = state.audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(state.audioContext.destination);
                source.start(0);
                source.disconnect();
            }
            window.removeEventListener('click', initAudio);
        }, { once: true });
        
        // Initialize the app
        function init() {
            createPresetsUI();
            applySelectedPresetOnLoad();
            updateSliderPosition();
            updateTimerDisplay();
            checkOrientation();
            adjustFontSize();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>